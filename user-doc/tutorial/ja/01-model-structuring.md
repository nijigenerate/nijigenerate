# モデル構成チュートリアル（はじめての Node / Part 設計）

キャラクターモデルを組むときに「どこをどう分けて、どんな順番で親子を作るか」をまとめた手順書です。  
この通りに組むと、

- 後からパーツを増やしても破綻しにくい  
- AutoMesh を掛けやすい  
- 首や髪を回したときに破綻しにくい

といった “扱いやすいモデル構成” になります。

---

## 1. まず「モデル構成」をざっくり理解する

最初に、よく登場する単語と役割だけ押さえておきましょう。  
細かいことは、手を動かしながら覚えれば大丈夫です。

- `Root`  
  モデル全体のいちばん上にある根っこのノードです。  
  ここから下に、頭・胴・手足…といったブロックがぶら下がります。

- `Part`  
  実際に絵（パーツ画像）を持つノードです。  
  「形がある」のは基本的に Part だけ、と覚えておくと整理しやすくなります。

- `Node`  
  ピボット（回転の中心）やオフセットを調整するための“空の箱”です。  
  見た目は持たず、子どもの Part をまとめる役をします。

- `Composite` / `DynamicComposite`  
  目・口の差分など、複数の Part をひとまとめにして制御したいときに使う“まとめ役”です。

- `GridDeformer`  
  顔や胴体などの広い面を、グリッドでぐにゃっと変形させるためのノードです。  
  Grid 自体には絵はなく、子どもの Part をまとめて変形します。

以降のステップでは、

- 「形を持つのは Part」  
- 「それ以外（Node, Composite, GridDeformer）は補助役」

という前提で、ツリーを組んでいきます。

---

## 2. チュートリアルで目指すツリーの形

まずは次の形を目標にします（キャラによって多少増減してOKです）。

- Root のすぐ下には「胴（上半身）」や「脚（下半身）」などの“大枠”を置く
- 首〜顔・腕・（翼/尻尾/背後のリボン等の）衣装に紐づく大きな独立パーツは、**`Body`（Part）や土台 Part を基準**にぶら下げる
- 脚は Root 直下を推奨（胴体に合わせて脚が動くと、地面に接地していないような動きになりやすいので、上半身と切り離す）
- 首は胴の子、顔は首の子にする（顔の子に目・口・耳、影はそれぞれの本体の子）
- 手足や後頭部の髪は「付け根から先端」に向かって並べる（体に近い側を親、先端側を子にする）
- 広い面（顔・後頭部・胴・前髪・胸）には GridDeformer を 1 個ずつ入れる

---

## 3. 迷ったときの判断ガイド

ツリーを編集していると「どの操作を選べばいいか」で手が止まりがちです。  
迷ったら、次の判断だけ先に決めてから手を動かします。

### 3.0 このチュートリアルで言う「親子」は Part 同士のつながり

ここがいちばん誤解されやすいポイントです。

- 「首は胴の子」「目や口は顔の子」「腕は胴の子」のような言い方は、**見た目（画像）を持つ Part 同士の親子関係**を指します。
- `Node` や `GridDeformer` は補助役で、Part の上下に挟み込むことはありますが、**“胴→首→顔” や “顔→目/口” といった骨格のつながりを置き換えるものではありません。**

たとえば胴に `Body::G (GridDeformer)` を挿入する場合、正しい考え方は次のどちらかです。

- `Body::G` の **子に `Body (Part)` を残し**、首は `Body (Part)` の子にする（基本）  
- どうしても意図があって `Body::G` を親にしたい場合でも、**「胴の基準は Body Part」だと分かる形**（Body Part を間に残すなど）にして、首を “胴 Part の子” として扱える状態にする

以降の手順で「〜の子にする」と書いてある箇所は、**まず Part を基準に親子を作り、必要なら途中に Node/GridDeformer を挟む**、という意味で読んでください。

### 3.0.1 Node を挟むのは「独立で動かすことが多いパーツ」だけ

Node を挟むのは万能ルールではありません。  
主に、胴体に対して **独立で動かすことが多いパーツ**（腕・顔、キャラによっては脚など）で使います。

これらは、親（胴体）の変形の影響をそのまま受けると破綻しやすく、また回転の中心も個別に欲しくなることが多いので、親 Part と子 Part の間に **Node を 1 枚挟む**と扱いやすくなります。

基本形は次の 3 段です（腕・顔・必要なら脚で使う形）。

- 親（`Part`）  
  ↓  
- `Node`（**子パーツを選んで「親として挿入（Insert）」で作る**）  
  ↓  
- 子（`Part` など）

ポイントは「Node を上位で新規追加する」のではなく、**子パーツに対して親として挿入する**ことです。  
こうすると Node の原点が子パーツに揃い、位置ズレを起こしにくく、変形の影響も調整しやすくなります。

### 3.1 「親を 1 段増やしたい」なら Insert（挿入）を選ぶ

**こんなとき**

- 回転の中心（ピボット）を作りたい（首の付け根、腕の付け根、口の開閉の基準など）
- すでにある Part をまとめたい（目や口をまとめて ON/OFF したい、差分をまとめたい）
- 既存の親子関係の「間に」ノードを差し込みたい

**なぜ Insert なのか**

挿入（Insert）は「選んだ対象の親として差し込む」動作なので、**挿入されたノードの原点を対象パーツの位置に合わせやすい**のが利点です。  
逆に追加（AddNode）は「親の子として新規ノードを足す」動作になりやすく、原点が親側の座標や既定位置に寄ってしまいます。結果として、

- 回転させたら大きくズレる  
- 変形やマスクの基準が合わない  
- 後から直す手間が増える

というケースが大量に起きます。**階層化が目的なら、基本は Insert を選ぶ**と覚えてください。

### 3.2 「すでに階層はあるが、種類が違う」なら ConvertTo（変換）を使う

**こんなとき**

- すでに `Node` で階層化されているが、本当は `DynamicComposite` にしたい（目・口など）
- すでに `Node` で階層化されているが、本当は `GridDeformer` にしたい（前髪・胴体・横髪などを「グリッドで変形」したい）
- まとめ役の種類が違うせいで、差分管理やマスクがやりづらい

**なぜ ConvertTo なのか**

この状況は、ノードを「挿入」や「追加」しても根本は解決しません。  
欲しいのは “階層の追加” ではなく “ノード種別の置き換え” だからです。そこで **ConvertTo で種類そのものを変える**のが最短です。

**補足（GridDeformer にしたいとき）**

前髪・胴体・横髪などをグリッドで変形したいときは、状況によってやり方を分けます。

- すでにその位置に「まとめ用の `Node`」が入っている  
  → その `Node` を `GridDeformer` に **ConvertTo（変換）** して、その場で置き換えます（階層を増やさず、位置関係も保ちやすいです）。
- その位置に置き換えたい `Node` が無い／グリッドを 1 枚追加して包みたい  
  → 変形させたい **Part** を選び、その **親として GridDeformer を挿入**します（ステップ 5）。

### 3.3 ConvertTo で Node → DynamicComposite にしたときの注意（autoResizedMode）

Node を DynamicComposite に変換した直後は、表示や当たり判定のリサイズが追いつかないことがあります。  
その場合は `autoResizedMode` を **2 回トグル**（ON→OFF あるいは OFF→ON を 2 回）して、リサイズを確定させてください。  
ここをやらないと「見た目は合っているのにマスクがズレる」などの違和感が残ることがあります。

### 3.4 目と口は「同じ考え方」でまとめる（DynamicComposite 推奨）

目だけ DynamicComposite にして口はバラバラ、という構成にすると、口の差分やマスク管理だけが別ルールになって破綻しやすくなります。  
**口も目と同じように DynamicComposite でまとめる**と、

- 表情差分の追加・切替が楽  
- 影やマスクの親子関係が整理しやすい  
- 後から拡張しやすい

というメリットがあります。

### 3.5 腕・脚・口など「連結して動くもの」は付け根→先端の順に並べる

**なぜ付け根→先端なのか**

連結パーツは親の動きが子へ伝わるため、付け根が親、先端が子の順にすると自然な追従になります。逆に先端を親にすると、

- 付け根が抜ける／引きつる  
- 回転中心が取りづらい  
- 物理や変形の設定がややこしくなる

といった問題が起きやすくなります。腕・脚だけでなく、口の開閉・顎周りなども「基準（付け根）→末端（先端）」の順で揃えるのがおすすめです。

### 3.6 Grid / AutoMesh / 一括操作は「作業を減らすための道具」

- GridDeformer の格子数は、顔や後頭部は **8×8 程度**、胴体は **10×14 程度**を起点に、縦横比で微調整します。  
- AutoMesh は、GridDeformer は Grid 用、Part は Optimum を基本にします。  
- 同じ操作を何度も繰り返す場面（挿入・追加・メッシュ定義・複数の子を同じ親へ移動など）は、複数選択して一括で行うとミスが減ります。API から操作する場合も、対象を Context に一括指定して一度に実行するのが簡単です。

---

## 4. 準備

最初に、次の状態にしておきます。

- キャラクターの画像素材（頭・胴・腕・脚・髪・衣装など）が、ある程度 Part として読み込まれている
- エディタ上で、ツリー（Node/Part の一覧）が見える状態になっている

もしまだ画像読み込みや Part 作成の操作に不安がある場合は、  
先に「画像読み込み〜基本の Part 作成」のチュートリアルを一度なぞっておくとスムーズです。

---

## 5. ステップバイステップで構成を組む

### ステップ 1：Root 直下に「大ブロック」を作る

最初に、モデルをざっくりとしたブロックに分けます。  
ここで分けておくと、後で「胴体ごと少し上に」「頭だけ角度を変える」といった操作がしやすくなります。

**やること（考え方）**

- 胴・手足・（必要なら）翼/尻尾/背後リボン等の大きな独立パーツ・アクセなど **まとめたい Part 群を先に選択** し、「親として Node 挿入」でまとめます（名前は目安です）  
  `Body::Root`, `Arm R::Root`, `Arm L::Root`, `Leg R::Root`, `Leg L::Root`, `Wing::Root`, `Tail::Root`, `BackRibbon::Root`, アクセ系 … など  
  ※頭まわりは後続のステップ 2 で「首の子として顔をぶら下げる」形に整理します（必要なら `Face` の親として `Head::Root` のような Node を挿入してまとめます）。
  ※翼/尻尾/背後リボン等（`Wing::Root` / `Tail::Root` / `BackRibbon::Root` など）は後続のステップ 3 で、胴体やスカート等の **土台 Part の子**になるよう付け替えます（付け根に `Node` を挟んで分離）。
- こうして挿入された Node は、選択していた Part の原点位置を引き継ぐため、後から回転・移動の基準にしやすくなります（初期状態では Root 直下に仮置きされることが多いです）。
- 重要なのは「まとまりを作る」ことで、**最終的な配置はステップ 2/3 で整理します**（腕や衣装の独立パーツは `Body (Part)` や土台 Part 基準、脚は Root 直下に置くのがおすすめです）。

**よくある失敗**

- すべての Part を Root のすぐ下に並べてしまう  
  → 一見シンプルですが、後で「頭だけ動かしたい」「胴ごと動かしたい」ときに毎回複数選択が必要になり、破綻しやすくなります。

**具体的な操作例**

- 胴や手足用の Part 群を選択し、それぞれ「親として Node 挿入」で `Body::Root` や `Arm R::Root` などを作る  
- 頭まわりはステップ 2 で `Neck` → `Face` の順に組み替える（必要なら `Face` の親として `Head::Root` のような Node を挿入してまとめる）  
- このように「**先に対象 Part を選び、その親として挿入**」するのが基本パターンです

---

### ステップ 2：首・顔・目・口の親子関係を整える

次に、首から上の構造を整えます。  
ここをきちんと作っておくと、「首を回したときに顔全体が気持ちよく付いてくる」ようになります。

**理想的な関係**

- 首（`Neck` の Part）は胴（`Body` の **Part**）の子
- 顔（`Face` の Part）は首（`Neck` の **Part**）の子
- 目・口・耳の各 Part は顔（`Face` の **Part**）の子（目・口ともに DynamicComposite でまとめるのを推奨）
- 影用の Part は「影を落とされる本体 Part」の子

**よくある失敗**

- 顔の Part を胴体に直接ぶら下げてしまう  
  → 首だけ回そうとしても、うまく中心が取れず破綻しやすくなります。
- `GridDeformer` や `Node` の下に入れたからOKだと勘違いする  
  → 「胴の子」「顔の子」という条件は、**親が Part であること**が重要です（補助ノードの直下に置いても、Part 同士のつながりが崩れていると破綻します）。
- 影を別の場所に置いてしまう  
  → 動かしたときに影だけズレてしまいます。

**具体的な操作例**

- 胴体の Node（または Part）の子として `Neck` Part を配置する  
- `Neck` の子として `Face` Part をドラッグして移動する  
- 顔の中の Part（目・口・耳など）を、`Face` の子にまとめる  
- 影用の Part がある場合は、「本体 Part の子」となるようドラッグ

---

### ステップ 3：手足・後頭部の髪を「付け根から先端」に並べる

手足や髪の束など、細長く連結しているパーツは、

- 「付け根 → 中間 → 先端」（腕・脚・口などの連結パーツもこの順で徹底）

という順番でツリーに並べると扱いやすくなります。

**理想的な例**

- 腕なら：`Body (Part)` → `UpperArm (Part)` → `LowerArm (Part)` → `Hand (Part)`
- 脚なら：`Root` → `Leg R::Root` / `Leg L::Root`（Node） → `UpperLeg (Part)` → `LowerLeg (Part)` → `Foot (Part)`  
  ※脚は Root 直下に置いておくと、上半身の動きに引っ張られにくく、接地感が作りやすいです（必要なら `Leg R::Root` などで回転中心を作ります）。
- 翼/尻尾/背後リボン等の「衣装に紐づく大きな独立パーツ」なら：`Body (Part)`（またはスカート等の土台 Part） → `Wing::Root` / `Tail::Root` / `BackRibbon::Root`（Node） → `Base (Part)` → … → `Tip (Part)`  
  ※これらは胴体（やスカートなど）に「付いている」ので、Root 直下ではなく **土台 Part の子**にします。さらに、土台の変形（GridDeformer 等）の影響を受けにくくするため、**付け根に `Node` を 1 枚挟んでから**パーツをぶら下げておくのがおすすめです。
- 後ろ髪なら：`Head::Root` または `Body` → `BackHairRoot` → `HairChunk` → `HairTip`
- 口パーツを DynamicComposite でまとめる場合も、基準となる口ノードを付け根側に置き、その下に差分をぶら下げる

**よくある失敗**

- 手や髪の先端を親にしてしまう  
  → 先端を動かしたときに付け根が引きつったり、回転中心が不自然になりがちです。
- 翼/尻尾/背後リボン等を Root 直下に置いてしまう／土台 Part に直接ぶら下げてしまう  
  → 胴体やスカートの変形に巻き込まれて破綻しやすくなります（付け根に `Node` を挟んで分離しておくのが安全です）。

**具体的な操作例**

- 右腕の Part を、付け根に近い順に確認する  
- 付け根の Part を選び、「親として挿入（Insert）」で `Node` を差し込んで `Arm R::Root` のように名前を付ける  
- `Arm R::Root` の子に、`UpperArm` → `LowerArm` → `Hand` の順で Part を並べる  
- 脚は Root 直下に `Leg R::Root` / `Leg L::Root` を作り、その子に `UpperLeg` → `LowerLeg` → `Foot` の順で Part を並べる  
- 翼/尻尾/背後リボン等も同様に、胴体（またはスカート等）を土台として、その子に付け根 Part を置き、`Wing::Root` / `Tail::Root` / `BackRibbon::Root` のような `Node` を「親として挿入」してから、付け根→先端の順で並べる  
- 後ろ髪も同様に、付け根から先に向かって Node/Part を並べる

---

### ステップ 4：Node / Composite / DynamicComposite を「親として挿入」する

ここからは、補助用のノードを追加していきます。  
大事なルールは、「既存の子を別のツリーに引っ越さず、**親として挿入する**」ことです。  
特に、**「動かしたい Part を選んで、その親として挿入する」** のを基本とします。

Node / Composite / GridDeformer は、挿入時に「選択していたオブジェクトの原点」を引き継ぎます。  
そのため、上位の Node を選んで挿入すると、原点が大きくずれてしまい、回転や変形の基準が取りづらくなります。
常に「どの Part の原点を使いたいか」を意識して、その Part（たいていは子ども側の Part）を選んでから親として挿入してください。

**迷ったときの選び方（結論）**

- 親を 1 段「差し込みたい」→ **挿入（Insert）** を使う（原点ズレを避けたいので）  
- 種類が違うのを「置き換えたい」→ **変換（ConvertTo）** を使う  
  - Node → DynamicComposite の直後は `autoResizedMode` を **2 回トグル** してリサイズを反映  
  - 目だけでなく口も DynamicComposite にして、表情差分のルールを揃える

**考え方**

- Node, Composite, DynamicComposite は、既存の Part の **上に挟み込む** 形で追加します
- 「Part を選んで → 親として挿入」で作ると、元の位置関係を壊さずにピボットやまとめを追加できます

**用途の目安**

- 目・口の差分管理 … `Composite` または `DynamicComposite` を「親として挿入」
- 腕・脚の分節 … **起点となる（回転中心にしたい） Part を適切に選び**、その親として `Node` を挿入する

**具体的な操作例**

- 目の Part をまとめて選択 → 右クリックかメニューから「親として Composite 挿入」  
  → 生成された Composite に分かりやすい名前を付ける（`Eyes::Comp` など）
- 腕の付け根の Part を選択 → 「親として Node 挿入」  
  → `Arm R::Joint` のように名前を付けて、回転や移動の基準にする

---

### ステップ 5：GridDeformer を「必要な場所だけ」に入れる

GridDeformer はとても強力ですが、たくさん入れすぎると管理が大変になります。  
基本は、次の部分にだけ入れます（必要になったら追加します）。

- 顔
- 後頭部
- 横髪
- 胴体
- 前髪
- 胸（胸が別パーツのとき）

**手順の目安**

- すでに同じ位置に「まとめ用の `Node`」が入っていて、それをグリッドにしたい場合は、その `Node` を `GridDeformer` に **ConvertTo（変換）** して置き換えます
- まとめ用の `Node` が無い場合は、変形させたい **Part** を選択し、その **親として GridDeformer を挿入**します
- GridDeformer 自体にはメッシュ（AutoMesh）は掛けません  
  → Grid 用の専用 AutoMesh を使う場合を除き、基本は子の Part にメッシュを持たせます

格子数の目安としては、

- 顔や後頭部 … **8×8 程度**
- 胴体 … **10×14 程度**

をベースに、キャラクターの縦横比やディテールに合わせて縦横のマス数を少し増減させると、細かすぎず粗すぎない扱いやすい Grid になりやすいです。

また Grid のマージン（中身から枠までの余白）は**全体サイズの約 10% 前後**にすると、変形時にエッジが自然に変形しながらも余裕があり、Grid が狭すぎてパーツを押しつぶすような事態を避けられます。

### 補足：目・口の DynamicComposite とグリッド（目安）

目や口など、顔の差分管理に `DynamicComposite` を使う場合、グリッドにしておくと変形の影響が見えやすく、調整がしやすくなります。  
細かすぎると編集が重く、粗すぎると形が取りにくいので、まずは **6×6〜8×8 程度**を目安にして、必要に応じて増減してください。

**具体的な操作例**

- 顔の Part を選択 → 「親として GridDeformer 挿入」 → `Face::G` など名前を付ける  
  → `Face::G` の子に `Face` Part が残っていることを確認
- 同様に、後頭部・横髪・胴体・前髪・胸部にも必要に応じて GridDeformer を挿入

---

### ステップ 6：前髪の Grid と胸パーツ、衣装の配置

少しだけ応用として、前髪と胸パーツ、衣装の置き方を整えます。

**前髪専用 Grid**

- 顔とは別に、前髪だけを大きく変形させたい場合に使います
- 顔の子として `FrontHair::G (GridDeformer)` を置き、その下に前髪の Part をぶら下げます

**胸部が別パーツの場合**

- 胴体に GridDeformer を追加し、その子として胸部 Part を配置します  
  → 胴体のゆれや変形に胸も一緒に追従しやすくなります

**衣装（スカートなど）**

- スカートなど体についた衣装パーツは、胴体の子に置きます
- こうすることで、体と一緒に移動しつつ、必要に応じて衣装だけ回転・変形させることができます

---

### ステップ 7：AutoMesh の設定と一括操作

ツリー構成がある程度できたら、メッシュを張っていきます。

**基本ルール**

- `Part` … 基本は `Optimum` アルゴリズムで AutoMesh
- `GridDeformer` … Grid 用 AutoMesh（Grid プロセッサ）を使って **Grid で AutoMesh** する

**よくある失敗**

- GridDeformer に通常の Optimum メッシュを掛けてしまう  
  → 意図しない分割や重いメッシュになりがちです
- 逆に、Part に Grid 用の設定を使ってしまう  
  → メッシュが粗くなり、細かい変形がやりにくくなります

**複数パーツの一括操作（コンテキスト選択）**

- 同じようなパーツに同じ AutoMesh 設定を掛けたいときはもちろん、**ノードの挿入や追加、複数の子ノードを同じ親ノードに移す場合**なども、一括操作が便利です。
- 複数の Part / Node を選択 → Context に登録 → 一度の操作で AutoMesh、Node / Composite / GridDeformer の挿入、親変更などをまとめて適用できます。  
- API から操作する場合も同様に、対象オブジェクトを Context に一括指定しておくことで、同じパラメータの操作を一度に行うことができます。  
  （挿入・追加・メッシュ定義など「同じ設定で何度も繰り返す」作業は、基本的に Context に一括指定して行うことを推奨します）

---

## 6. 最後にチェックしたいポイント

簡単に動かしてみる前に、次のあたりを確認しておくと安心です。

- Root 直下に `Body`（上半身）と `Leg R/L`（下半身）などの大枠が整理されているか
- 腕や（必要なら）翼/尻尾/背後リボン等は、`Body` や土台 Part 基準でぶら下がっているか
- 顔は首の子、首は胴の子になっているか（**いずれも親が Part になっているか**）
- 手足や後ろ髪が「付け根 → 先端」の順で並んでいるか
- 影パーツが「影を落とす本体」の子になっているか
- GridDeformer が必要な場所にだけ入っていて、子に正しく Part がぶら下がっているか

ここまでできていれば、基本的なモーションや細かい調整を入れても壊れにくいモデル構成になっています。

---

## 7. 参考ツリー例（抽象化）

実際にはキャラクターごとに差はありますが、ここまでの内容を反映した一例を示します。

- `Root`  
  - `Body::G` (GridDeformer) → `Body` (Part)  
    - `Neck` (Part) → `Face::Root` (Node)  
      - `Face::G` (GridDeformer) → `Face` (Part)  
        - `Eyes` / `Mouth` / `Ear` （各 Part、必要に応じて Composite 親を追加）  
        - `FrontHair::G` (GridDeformer) → `FrontHair` (Part)  
      - `BackHair::G` (GridDeformer) → `BackHair` (Part)  
      - `SideHair::G` (GridDeformer) → `SideHair` (Part)  
    - `Arm R::Root` (Node) → `Arm R` (Part) → `Hand R` (Part + 影)  
    - `Arm L::Root` (Node) → `Arm L` (Part) → `Hand L` (Part + 影)  
    - `Skirt` (Part) → `Ribbon` / `Frill` (Part)  
      - （翼/尻尾/背後リボン等があるなら）`Tail::Root` / `Wing::Root` / `BackRibbon::Root` (Node) → `Base` (Part) → … → `Tip` (Part)  
    - （胸部が別パーツなら）`Chest::G` (GridDeformer) → `Chest` (Part)  
  - `Leg R::Root` / `Leg L::Root` (Node) → `UpperLeg` (Part) → `LowerLeg` (Part) → `Foot` (Part + 影)  
  - アクセサリ各種（必要に応じて Grid / 物理を追加）

---

ここまでの内容を守ってツリーを組めば、

- どこをどう動かすと何が動くのかが分かりやすい  
- AutoMesh の適用範囲とアルゴリズムを間違えにくい  
- 後からパーツを追加しても、構造を壊さずに拡張しやすい

といった “扱いやすいモデル構成” を作ることができます。
